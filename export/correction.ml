let devise n d = d mod n = 0let parfait n =  let rec somme_des_diviseurs_a_partir_de i = if i = n then 0    else somme_des_diviseurs_a_partir_de (i+1) + if devise i n then i else 0  in somme_des_diviseurs_a_partir_de 1 = nlet est_premier n =   let rec a_un_diviseur_sup_a i =    if i * i > n then false    else devise i n || a_un_diviseur_sup_a (i+1)  in   n >= 2 && not (a_un_diviseur_sup_a 2)let rec pgcd a b =  let r = b mod a in   if r = 0 then a  else pgcd r alet simplify(num1,denom1) =   let d = pgcd num1 denom1 in num1 / d, denom1 / dlet add_frac (num1, denom1) (num2, denom2) =   let num' = denom1 * num2 + num1*denom2 in  let denom' = denom1 * denom2 in  simplify(num', denom')let mult_frac (num1, denom1) (num2, denom2) =  let num' = num1 * num2 in  let denom' = denom1 * denom2 in  simplify(num',denom')let div_frac (num1,denom1) (num2,denom2) =   mult_frac (num1,denom1) (denom2, num2)let rec u u0 n = if n = 0 then u0 else                   let unmoinsun =  u u0 (n-1) in                       div_frac (mult_frac unmoinsun unmoinsun) (add_frac (mult_frac unmoinsun (2,1)) (1,1))let puissance_8 n = let rec carre nb t = if t = 1 then nb*nb else let number = carre nb (t-1) in number * number in carre n 3                   let test f a =   let st = Sys.time () in   let _ = f a in   Sys.time () - .stlet rec factorielle n = if n = 0 then 1 else n * factorielle (n-1)let rec fast_exp a b = let carre n = n*n in if b = 1 then a else                          if b mod 2 = 0 then carre(fast_exp a (b/2)) else                           a * carre(fast_exp a (b/2))let rec nb_chiffre n = if n/10 = 0 then 1 else 1 + nb_chiffre (n/10)let inverser n = let rec dixpuissance num = if num = 0 then 1 else 10 * dixpuissance (num-1) in                  let rec inverser_rec n nb_chiffres = if nb_chiffres = 1 then n else (n mod 10) * dixpuissance (nb_chiffres-1) + inverser_rec (n/10) (nb_chiffres-1) in inverser_rec n (nb_chiffre n)let palindrome n = if n = (inverser n) then true else falselet rec solve n = if palindrome( n * (inverser n)) then n else solve (n+1)let combiendefois42 n = let nb_chiffres = nb_chiffre n in if n mod 10 = 2 then if (n/10) mod 10 = 4 then 0let volsyraux n = if n mod 2 = 0 then (n/2) else (n*3+1)let vol_syracuse n =   let rec vol_syracuse_rec n compteur =     if n = 1 then compteur  else vol_syracuse_rec (volsyraux n) (compteur + 1) in   vol_syracuse_rec n 0let pic_syracuse n =  let rec pic_syracuse_rec n maxe =     if n = 1 then maxe else max n (pic_syracuse_rec (volsyraux n) maxe) in   pic_syracuse_rec n 0let distance (x1,y1) (x2,y2) = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** (1/2)